# `feat.py` - Cross-Project Feature Documentation Tool

`feat.py` is a lightweight, language-agnostic tool that helps keep feature documentation aligned with your project's code across multiple programming languages.

## Key Features

- 🌐 **Universal Repository Support**
  - Auto-detects repository root from any directory
  - Works with Rust, Python, TypeScript, and extensible to more languages
  - Uses `.feat.toml` for flexible configuration

- 📋 **Feature Inspection**
  - Walks module trees for specified features
  - Collects exported items (functions, structs, enums, types, etc.)
  - Generates comprehensive feature reports

- 📝 **Documentation Sync**
  - Updates documentation inline with code structure
  - Uses sentinel blocks for precise documentation management

## Installation

Install `feat.py` to your local bin directory:

```bash
# Option 1: Copy to local bin
cp bin/feat.py ~/.local/bin/feat
chmod +x ~/.local/bin/feat

# Option 2: Use symlink
ln -s /path/to/repo/bin/feat.py ~/.local/bin/feat

# Ensure ~/.local/bin is in your PATH
echo 'export PATH=$PATH:~/.local/bin' >> ~/.bashrc
source ~/.bashrc
```

## Configuration: `.feat.toml`

Create a `.feat.toml` in your project root to customize feature discovery:

```toml
# feat.py configuration (all optional, sensible defaults)
features_root = "src"                      # Where to scan for features
docs_root = "docs/features"                # Where feature docs live
doc_pattern = "FEATURES_{FEATURE}.md"      # Doc file naming pattern
languages = ["rust", "python"]             # Languages to parse
auto_discover = true                       # Auto-discover from src/

# Exclude patterns (glob-style)
exclude = [
    "**/tests/**",
    "**/target/**",
    "**/__pycache__/**",
]

[features]
# Explicit feature mappings (override auto-discovery)
# Format: feature_name = ["path/to/code", "other/path"]
colors = ["src/colors"]
logging = ["src/log", "src/utils/logging.rs"]
```

## Usage Examples

```bash
# Generate initial .feat.toml config
feat init

# List all discovered features
feat list
feat list --verbose    # Show paths and item counts

# Inspect a specific feature
feat scan colors
feat scan colors --format json

# Update feature documentation (creates or updates sentinel block)
feat update colors
feat update colors --doc path/to/custom.md

# Sync all feature docs at once
feat sync
feat sync --dry-run    # Preview changes without writing

# Validate configuration and check for issues
feat check
feat check --missing-docs    # Report features without docs

# Work with a specific repository (from anywhere)
feat --root /path/to/project list
feat --config /path/to/.feat.toml scan myfeature
```

## Sentinel Documentation Workflow

Feature docs use special markers for automatic updates:

```markdown
<!-- feat:colors -->

_Generated by bin/feat.py --update-doc._

* `src/colors/mod.rs`
  - fn color (line 42)
  - struct Color (line 10)

* `src/colors/macros.rs`
  - macro colored! (line 7)

<!-- /feat:colors -->
```

The `feat update` command replaces or appends the sentinel block with the latest code inventory. Manual documentation can be added outside these blocks.

## Best Practices

1. **Initialize early**: Run `feat init` when starting a new project
2. **Use auto-discovery**: Let the tool find features automatically, only add explicit mappings when needed
3. **Stub workflow**: The tool creates `.stub.md` files for missing docs - rename to `.md` when finalized
4. **Sync regularly**: Run `feat sync` after major refactoring to keep all docs current
5. **Commit .feat.toml**: Include configuration in version control for team consistency

## How It Works

1. **Repository Detection**: Walks up from current directory to find `.git`, `Cargo.toml`, `package.json`, etc.
2. **Configuration Loading**: Loads `.feat.toml` from repo root (or uses defaults)
3. **Feature Discovery**: Either auto-discovers from `features_root` or uses explicit `[features]` mappings
4. **Parsing**: Uses language-specific parsers to extract public items (functions, structs, macros, etc.)
5. **Documentation**: Updates sentinel blocks in markdown files with current code surface

## Language Support

| Language   | Status | Items Detected |
|------------|--------|----------------|
| Rust       | ✅ Full | `pub fn`, `pub struct`, `pub enum`, `pub trait`, `pub type`, `pub use`, `#[macro_export]` |
| Python     | ✅ Full | `class`, `def`, `__all__` exports |
| TypeScript | 🚧 Stub | Placeholder (not implemented) |

## Troubleshooting

**Tool not found after installation:**
```bash
# Verify ~/.local/bin is in PATH
echo $PATH | grep .local/bin
# If not, add to ~/.bashrc or ~/.zshrc
export PATH="$HOME/.local/bin:$PATH"
```

**No features discovered:**
- Check `features_root` in `.feat.toml` points to correct directory
- Verify directory structure matches expected pattern (subdirectories = features)
- Use `feat check` to diagnose issues

**Parsing errors:**
- Tool uses lightweight regex parsing, may miss complex patterns
- Check file encoding (UTF-8 expected)
- Report issues with example code

## Design Philosophy

- **Convention over configuration**: Works zero-config in standard layouts
- **Lightweight parsing**: No compiler dependencies, pure regex-based extraction
- **Repository-agnostic**: Detects and adapts to any project structure
- **Non-invasive**: Only updates designated sentinel blocks in docs

## Limitations & Future Work

- Regex-based parsing may miss complex or nested declarations
- No support for private/internal API documentation (by design)
- TypeScript parser is stubbed (contributions welcome)
- Multi-language repos pick primary language by file count

## Contributing

Contributions welcome! Areas of interest:
- Additional language parsers (Go, Java, C++, etc.)
- Enhanced TypeScript support
- Configuration validators
- Test coverage improvements

## Related Tools

- [rustdoc](https://doc.rust-lang.org/rustdoc/) - Official Rust documentation generator
- [Sphinx](https://www.sphinx-doc.org/) - Python documentation builder
- [TypeDoc](https://typedoc.org/) - TypeScript documentation generator

`feat.py` complements these by providing lightweight, cross-language feature inventories in markdown format.